
garble -literals build
exec ./main$exe
cmp stderr main.stderr
! binsubstr main$exe 'garbleDecrypt' 'Lorem' 'ipsum' 'dolor' 'first assign' 'second assign' 'First Line' 'Second Line' 'map value' 'to obfuscate' 'also obfuscate' 'stringTypeField String' 'stringTypeStruct' '2824583991413579605' '3735714531481032066'

binsubstr main$exe 'also skip this' 'skip typed const' 'skip typed var' 'skip typed var assign' 'stringTypeField strType' 'stringType lambda func return' 'testMap1 key' 'testMap2 key' 'testMap3 key' 'testMap1 value' 'testMap2 value' 'testMap3 value' 'testMap1 new value' 'testMap2 new value' 'testMap3 new value' 'stringType func param' 'stringType return'
[short] stop # checking that the build is reproducible is slow

# Also check that the binary is reproducible.
cp main$exe main_old$exe
rm main$exe
garble -literals build
bincmp main$exe main_old$exe

-- go.mod --
module test/main
-- main.go --
package main

type strucTest struct {
	field        string
	anotherfield string
}

const (
	cnst      string = "Lorem"
	multiline        = `First Line
Second Line`
)

const (
	i       = 1
	boolean = true
)

const (
	foo = iota
	bar

	skip2 = "also skip this"
)

const arrayLen = 4

var array [arrayLen]byte

type typeAlias [arrayLen]byte

func main() {
	empty := ""

	localVar := "dolor"

	reassign := "first assign"
	reassign = "second assign"

	println(cnst, boolean)
	println(multiline)
	println(localVar)
	println(reassign)
	println(empty)

	x := strucTest{
		field:        "to obfuscate",
		anotherfield: "also obfuscate",
	}

	println(x.field, x.anotherfield)

	testMap := map[string]string{"map key": "map value"}
	testMap["map key"] = "new value"
	println(testMap["map key"])
	println("another literal")
	println(skip2)
	println(boolean, i, foo, bar)
	typedTest()
	constantTest()
	numTest()
	byteTest()
	boolTest()
}

type stringType string

type stringTypeStruct struct {
	str     string
	strType stringType
}

// typedTest types defined from string broke previously
func typedTest() {
	const skipTypedConst stringType = "skip typed const" // skip
	var skipTypedVar stringType = "skip typed var"       // skip

	var skipTypedVarAssign stringType
	skipTypedVarAssign = "skip typed var assign" // skip

	println(skipTypedConst, skipTypedVar, skipTypedVarAssign)

	y := stringTypeStruct{
		str:     "stringTypeField String",  // obfuscate
		strType: "stringTypeField strType", // skip
	}
	println(y.str, y.strType)

	z := func(s stringType) stringType {
		return "stringType lambda func return" // skip
	}("lambda call") // skip
	println(z)

	testMap1 := map[string]stringType{"testMap1 key": "testMap1 value"} // skip
	testMap1["testMap1 key"] = "testMap1 new value"                     // skip

	testMap2 := map[stringType]string{"testMap2 key": "testMap2 value"} // skip
	testMap2["testMap2 key"] = "testMap2 new value"                     // skip

	testMap3 := map[stringType]stringType{"testMap3 key": "testMap3 value"} // skip
	testMap3["testMap3 key"] = "testMap3 new value"                         // skip

	println(stringTypeFunc("stringType func param")) // skip
}

// constantTest tests that string constants which need to be constant are skipped
func constantTest() {
	const a = "foo" // skip
	const length = len(a)

	const b = "bar" // skip
	type T [len(b)]byte

	const c = "foo" // skip
	var _ [len(c)]byte

	const d = "foo" // skip
	var arr = [5]string{len(d): "foo"}
	for _, elm := range arr {
		if elm != "" {
			println(elm)
		}
	}

	const e = "foo" // skip
	var slice = []string{len(e): "foo"}
	for _, elm := range slice {
		if elm != "" {
			println(elm)
		}
	}

	const f = "foo" // skip
	const i = length + len(f)
}

func numTest() {
	const a = 1 // skip

	const b = a + 2 // skip

	const c = 2824583991413579605

	d := 4

	var e = 5

	var f int
	f = 3735714531481032066

	println(a, b, c, d, e, f)

	var (
		untypedInt       = -3453453534423 + 12
		intVar     int   = -3453453534423
		int8Var    int8  = -122.0
		int16Var   int16 = 3534
		int32Var   int32 = 333453534
		int64Var   int64 = 3453453534423

		uintVar    uint    = 3453453534423
		uint8Var   uint8   = 34
		uint16Var  uint16  = 3534
		uint32Var  uint32  = 333453534
		uint64Var  uint64  = 3453453534423
		uintptrVar uintptr = 3453453534423

		untypedFloat         = 3.0
		floatVar     float64 = 75453453534
		floatVar32   float32 = -435453453534

		complexVar64  complex64  = -435453453534 // skip
		complexVar128 complex128 = 1 + 4i        // skip
	)

	floatShort := -435453453534.0
	println(untypedInt, intVar, int8Var, int16Var, int32Var, int64Var)
	println(uintVar, uint8Var, uint16Var, uint32Var, uint64Var, uintptrVar)
	println(untypedFloat, floatVar, floatShort, floatVar32)
	println(complexVar64, complexVar128)

}

func byteTest() {
	a := []byte{12, 13}
	for _, elm := range a {
		print(elm, ", ")
	}
	println()
	var b = []byte{12, 13}
	for _, elm := range b {
		print(elm, ", ")
	}
	println()

}

func boolTest() {
	const a = true // skip

	const b = false == a // skip

	const c bool = false

	d := true

	var e = true

	var f bool
	f = false

	println(a, b, c, d, e, f)
}

func stringTypeFunc(s stringType) stringType {
	println(s)
	return "stringType return" // skip
}

-- main.stderr --
Lorem true
First Line
Second Line
dolor
second assign

to obfuscate also obfuscate
new value
another literal
also skip this
true 1 0 1
skip typed const skip typed var skip typed var assign
stringTypeField String stringTypeField strType
stringType lambda func return
stringType func param
stringType return
foo
foo
1 3 2824583991413579605 4 5 3735714531481032066
-3453453534411 -3453453534423 -122 3534 333453534 3453453534423
3453453534423 34 3534 333453534 3453453534423 3453453534423
+3.000000e+000 +7.545345e+010 +1.844674e+019 +2.633204e+009
(-4.354535e+011+0.000000e+000i) (+1.000000e+000+4.000000e+000i)
12, 13, 
12, 13, 
true false false true true false
